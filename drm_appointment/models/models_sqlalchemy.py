"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import datetime
import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class PatientDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: str
    name: typing.Optional[str]


class TPatient(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Patient data

    Attrs:
        id: The id of the Patient.
        name: The name of the Patient.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: "sqlalchemy.Column[str]"
    name: "sqlalchemy.Column[typing.Optional[str]]"

    def __init__(self, id: typing.Optional[str] = None, name: typing.Optional[str] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Patient.
            name: The name of the Patient.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[str] = None, name: typing.Optional[str] = None) -> "TPatient":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Patient.
            name: The name of the Patient.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TPatient":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> PatientDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Patient: typing.Type[TPatient] = models.Patient  # type: ignore


class PhysicianDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: str
    name: str


class TPhysician(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Physician Data

    Attrs:
        id: The id of the Physician.
        name: The name of the Physician.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: "sqlalchemy.Column[str]"
    name: "sqlalchemy.Column[str]"

    def __init__(self, id: typing.Optional[str] = None, name: typing.Optional[str] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Physician.
            name: The name of the Physician.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[str] = None, name: typing.Optional[str] = None) -> "TPhysician":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Physician.
            name: The name of the Physician.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TPhysician":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> PhysicianDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Physician: typing.Type[TPhysician] = models.Physician  # type: ignore


class AppointmentDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: str
    start_date: typing.Optional[str]
    end_date: typing.Optional[str]
    physician: typing.Optional["PhysicianDict"]
    patient: typing.Optional["PatientDict"]
    price: typing.Optional[float]


class TAppointment(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Appontiment Data

    Attrs:
        id: The id of the Appointment.
        start_date: The start_date of the Appointment.
        end_date: The end_date of the Appointment.
        physician: The physician of the Appointment.
        patient: The patient of the Appointment.
        price: The price of the Appointment.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: "sqlalchemy.Column[str]"
    start_date: "sqlalchemy.Column[typing.Optional[datetime.datetime]]"
    end_date: "sqlalchemy.Column[typing.Optional[datetime.datetime]]"
    physician: 'sqlalchemy.Column[typing.Optional["TPhysician"]]'
    patient: 'sqlalchemy.Column[typing.Optional["TPatient"]]'
    price: "sqlalchemy.Column[typing.Optional[float]]"

    def __init__(
        self,
        id: typing.Optional[str] = None,
        start_date: typing.Optional[datetime.datetime] = None,
        end_date: typing.Optional[datetime.datetime] = None,
        physician: typing.Optional["TPhysician"] = None,
        patient: typing.Optional["TPatient"] = None,
        price: typing.Optional[float] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the Appointment.
            start_date: The start_date of the Appointment.
            end_date: The end_date of the Appointment.
            physician: The physician of the Appointment.
            patient: The patient of the Appointment.
            price: The price of the Appointment.

        """
        ...

    @classmethod
    def from_dict(
        cls,
        id: typing.Optional[str] = None,
        start_date: typing.Optional[datetime.datetime] = None,
        end_date: typing.Optional[datetime.datetime] = None,
        physician: typing.Optional["PhysicianDict"] = None,
        patient: typing.Optional["PatientDict"] = None,
        price: typing.Optional[float] = None,
    ) -> "TAppointment":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Appointment.
            start_date: The start_date of the Appointment.
            end_date: The end_date of the Appointment.
            physician: The physician of the Appointment.
            patient: The patient of the Appointment.
            price: The price of the Appointment.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TAppointment":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> AppointmentDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Appointment: typing.Type[TAppointment] = models.Appointment  # type: ignore
